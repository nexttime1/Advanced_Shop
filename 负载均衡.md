### 细节

服务发现和负载均衡的细节 

```
resolver 负责 告诉 gRPC：现在有哪些服务地址
 balancer 负责 为这些地址建立连接 & 管理连接状态
 picker 负责 每一次 RPC 用哪一条连接
```



![image-20260122222259965](C:\Users\20839\AppData\Roaming\Typora\typora-user-images\image-20260122222259965.png)

## 负载均衡

`DialContext` 函数  （相关部分）

```GO
func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) {
  
	/*
    2. 创建负载均衡器
    解析器拿到 IP 列表后，enforcer 会根据服务配置（比如你设置的 round_robin 轮询策略）；
    调用负载均衡器的 Builder 创建负载均衡器实例；
    负载均衡器开始工作：管理后端 IP 列表 → 选择下一个要连接的 IP → 为这个 IP 创建底层连接。
    3. 初始化连接池
    负载均衡器选好 IP 后，enforcer 会创建 addrConn（底层 TCP 连接）；
    把这些 addrConn 加入 cc.conns（NewClient 里初始化的 make(map[*addrConn]struct{})）；
    形成连接池：后续 RPC 调用从连接池里选可用的连接发请求。
    */
	if err := cc.idlenessMgr.ExitIdleMode(); err != nil {
		return nil, err
	}
    
    
    
    
    
    
}
```



深入了解  `cc.idlenessMgr.ExitIdleMode()`  这个函数

```GO
func (m *Manager) ExitIdleMode() error { //这个函数是跳出 空闲状态 因为来订阅者了
	// Holds idleMu which ensures mutual exclusion with tryEnterIdleMode.
	m.idleMu.Lock()
	defer m.idleMu.Unlock()
	// 这里面 先判断如果连接已经关了，或者本来就不是真的空闲（比如已经在连接中），就啥也不用干，直接返回，
	if m.isClosed() || !m.actuallyIdle {
		return nil
	}
    // 如果是空闲 那就调用m.enforcer.ExitIdleMode() 而这个是接口 
	if err := m.enforcer.ExitIdleMode(); err != nil {
		return fmt.Errorf("failed to exit idle mode: %w", err)
	}

	// Undo the idle entry process. This also respects any new RPC attempts.
	atomic.AddInt32(&m.activeCallsCount, math.MaxInt32)
	m.actuallyIdle = false

	// Start a new timer to fire after the configured idle timeout.
	m.resetIdleTimerLocked(m.timeout)
	return nil
}

```

`enforcer`  是下面结构体赋值的 最终调用的是  `cc.exitIdleMode` 函数

```go
func (i *idler) ExitIdleMode() error {
	return (*ClientConn)(i).exitIdleMode()
}
```

 `cc.exitIdleMode` 函数

```GO
func (cc *ClientConn) exitIdleMode() (err error) {
	cc.mu.Lock()
	if cc.conns == nil {
		cc.mu.Unlock()
		return errConnClosing
	}
	cc.mu.Unlock()

	// This needs to be called without cc.mu because this builds a new resolver
	// which might update state or report error inline, which would then need to
	// acquire cc.mu.
	if err := cc.resolverWrapper.start(); err != nil {
		return err
	}

	cc.addTraceEvent("exiting idle mode")
	return nil
}

```

`start` 函数

```go
func (ccr *ccResolverWrapper) start() error {
	errCh := make(chan error)  // 因为下面是异步 所以要阻塞一下
	ccr.serializer.TrySchedule(func(ctx context.Context) {
		if ctx.Err() != nil {  // clientconn 给挂了 那没必要了
			return
		}
		opts := resolver.BuildOptions{  // 封装一下
			DisableServiceConfig: ccr.cc.dopts.disableServiceConfig,
			DialCreds:            ccr.cc.dopts.copts.TransportCredentials,
			CredsBundle:          ccr.cc.dopts.copts.CredsBundle,
			Dialer:               ccr.cc.dopts.copts.Dialer,
			Authority:            ccr.cc.authority,
			MetricsRecorder:      ccr.cc.metricsRecorderList,
		}
		var err error
		//第一个分支 注册的 resolver 直接生效    gRPC 不插手  不想要任何 gRPC 默认行为 没有保底
        // 使用的话 grpc.WithNoProxy() grpc.WithContextDialer(...)
		if ccr.cc.dopts.copts.Dialer != nil || !ccr.cc.dopts.useProxy {
			ccr.resolver, err = ccr.cc.resolverBuilder.Build(ccr.cc.parsedTarget, ccr, opts)
		} else {
            // 第二个分支 grpc 会帮你  Proxy 判断 本地 DNS 优化 scheme fallback 等等 我们走这个
			ccr.resolver, err = delegatingresolver.New(ccr.cc.parsedTarget, ccr, opts, ccr.cc.resolverBuilder, ccr.cc.dopts.enableLocalDNSResolution)
		}
		errCh <- err
	})
	return <-errCh
}
```

```
执行我自己的build方法 然后经过一系列操作那是服务发现的逻辑这边简单化 最终拿到 实例我自己定义的实例 通知给grpc要转成他自己的，也就是执行下面这个函数
```

`update`   函数 调用 `UpdateState` 

```GO
func (r *discoveryResolver) update(ins []*registry.ServiceInstance) {
	addrs := make([]resolver.Address, 0)
	endpoints := make(map[string]struct{})
	for _, in := range ins {
		endpoint, err := ParseEndpoint(in.Endpoints, "grpc", !r.insecure)
		if err != nil {
			log.Errorf("[resolver] Failed to parse discovery endpoint: %v", err)
			continue
		}
		if endpoint == "" {
			continue
		}
		// filter redundant endpoints
		if _, ok := endpoints[endpoint]; ok {
			continue
		}
		endpoints[endpoint] = struct{}{}
		addr := resolver.Address{
			ServerName: in.Name,
			Attributes: parseAttributes(in.Metadata),
			Addr:       endpoint,
		}
		addr.Attributes = addr.Attributes.WithValue("rawServiceInstance", in)
		addrs = append(addrs, addr)
	}
	if len(addrs) == 0 {
		log.Warnf("[resolver] Zero endpoint found,refused to write, instances: %v", ins)
		return
	}
	err := r.cc.UpdateState(resolver.State{Addresses: addrs}) // gRPC 客户端更新地址列表
	if err != nil {
		log.Errorf("[resolver] failed to update state: %s", err)
	}
	b, _ := json.Marshal(ins)
	log.Infof("[resolver] update instances: %s", b)
}
```

`UpdateState` 函数

```GO
// UpdateState is called by resolver implementations to report new state to gRPC
// which includes addresses and service config.
func (ccr *ccResolverWrapper) UpdateState(s resolver.State) error {
	ccr.cc.mu.Lock()
	ccr.mu.Lock()
	if ccr.closed {
		ccr.mu.Unlock()
		ccr.cc.mu.Unlock()
		return nil
	}
    // 兼容处理
	if s.Endpoints == nil {
		s.Endpoints = addressesToEndpoints(s.Addresses)
	}
	ccr.addChannelzTraceEvent(s)
	ccr.curState = s
	ccr.mu.Unlock()
    // 把解析器状态转发给 ClientConn 的核心处理函数  解锁在函数里面   ccr.cc.mu.Lock()
    // 这里的s 就是 结构体 里面有个 addresses 字段 就是全部的我自己 registry.ServiceInstance 转换的
	return ccr.cc.updateResolverStateAndUnlock(s, nil)
}
```

`updateResolverStateAndUnlock` 函数

```GO
func (cc *ClientConn) updateResolverStateAndUnlock(s resolver.State, err error) error {
	// 触发 firstResolveEvent：通知 DialContext 解析器已完成第一次解析（阻塞等待的逻辑会感知）
	defer cc.firstResolveEvent.Fire()

	// 防御：如果 ClientConn 已关闭（conns 置 nil 是关闭标志），直接返回
	if cc.conns == nil {
		cc.mu.Unlock()
		return nil
	}

	// ========== 分支1：解析器返回错误（比如注册中心（etcd/nacos）宕机 ==========
	if err != nil {
		// 应用默认服务配置（比如你在 NewClient 里解析的 round_robin 策略）
		cc.maybeApplyDefaultServiceConfig()
		// 通知负载均衡器：解析器出错，触发失败逻辑（比如标记所有节点不可用）
		cc.balancerWrapper.resolverError(err)
		// 无有效地址，返回错误
		cc.mu.Unlock()
		return balancer.ErrBadResolverState
	}

	var ret error
	// ========== 分支2：禁用服务配置（用户显式配置 WithDisableServiceConfig） ==========
	if cc.dopts.disableServiceConfig {
		channelz.Infof(logger, cc.channelz, "ignoring service config from resolver (%v) and applying the default because service config is disabled", s.ServiceConfig)
		// 应用默认服务配置（NewClient 里解析的 JSON 配置）
		cc.maybeApplyDefaultServiceConfig()
	// ========== 分支3：解析器未返回服务配置（只用默认配置） ==========
	} else if s.ServiceConfig == nil {
		cc.maybeApplyDefaultServiceConfig()
	// ========== 分支4：解析器返回了有效服务配置（核心分支） ==========
	} else {
		// 校验服务配置是否合法（转成 gRPC 内部的 ServiceConfig 结构体）
		if sc, ok := s.ServiceConfig.Config.(*ServiceConfig); s.ServiceConfig.Err == nil && ok {
			// 获取服务配置选择器（用于选择负载均衡、重试策略）
			configSelector := iresolver.GetConfigSelector(s)
			if configSelector != nil {
				if len(s.ServiceConfig.Config.(*ServiceConfig).Methods) != 0 {
					channelz.Infof(logger, cc.channelz, "method configs in service config will be ignored due to presence of config selector")
				}
			} else {
				// 使用默认配置选择器（封装负载均衡策略）
				configSelector = &defaultConfigSelector{sc}
			}
			// ########### 关键步骤：应用服务配置 + 初始化负载均衡器 ###########
            // 调用你注册的 balancer.Builder（比如 p2c.NewBuilder()），创建 p2c.Balancer 实例；
			cc.applyServiceConfigAndBalancer(sc, configSelector)
		} else {
			// 服务配置解析失败，返回错误
			ret = balancer.ErrBadResolverState
			if cc.sc == nil {
				// 如果从未收到过有效服务配置，应用“失败负载均衡策略”（所有调用直接失败）
				cc.applyFailingLBLocked(s.ServiceConfig)
				cc.mu.Unlock()
				return ret
			}
		}
	}

	// ========== 核心：把地址列表 + 负载均衡配置传给 balancerWrapper ==========
	// 7. 取出已解析的负载均衡配置（比如 round_robin）
	balCfg := cc.sc.lbConfig
	// 8. 拿到 NewClient 里初始化的 balancerWrapper（负载均衡器包装器）
	bw := cc.balancerWrapper
	// 解锁：前面的 cc.mu.Lock 在这里释放
	cc.mu.Unlock()

	// 9. 通知 balancerWrapper 更新客户端连接状态（地址列表 + 负载均衡策略）
	//    这是「解析器 → 负载均衡器」的最终传递步骤
	uccsErr := bw.updateClientConnState(&balancer.ClientConnState{
		ResolverState: s,       // 解析器的地址列表
		BalancerConfig: balCfg, // 负载均衡策略配置
	})
	if ret == nil {
		ret = uccsErr // 优先返回解析器相关错误
	}
	return ret
}

```



`NewClient` 函数 （相关部分）

```go
func NewClient(target string, opts ...DialOption) (conn *ClientConn, err error) {
    //  初始化负载均衡选择器包装器
	cc.pickerWrapper = newPickerWrapper()
    
    // 解析用户传入的 JSON 格式服务配置（比如负载均衡策略、重试次数）；
    // defaultServiceConfigRawJSON：用户传入的 JSON 字符串（比如 {"loadBalancingPolicy":"round_robin"}）；
	// parseServiceConfig：将 JSON 转换成 gRPC 内部的 ServiceConfig 结构体（方便后续使用）。
	if cc.dopts.defaultServiceConfigRawJSON != nil {
		scpr := parseServiceConfig(*cc.dopts.defaultServiceConfigRawJSON, cc.dopts.maxCallAttempts)
		if scpr.Err != nil {
			return nil, fmt.Errorf("%s: %v", invalidDefaultServiceConfigErrPrefix, scpr.Err)
		}
		cc.dopts.defaultServiceConfig, _ = scpr.Config.(*ServiceConfig)
	}
    
    // 创建连接状态管理器，负责维护 ClientConn 的整体状态（Idle/Connecting/Ready 等）；
    // 维护 ClientConn 的整体状态（Idle/Ready/TransientFailure 等），只有Ready状态的节点才会被纳入负载均衡选择范围；
	cc.csMgr = newConnectivityStateManager(cc.ctx, cc.channelz)
    
    
    // 管理自研Balancer的创建 / 销毁，接收解析器推送的节点列表，监听节点连接状态（如某个节点断连则标记不可用）；
    /*
    cc.resolverWrapper = newCCResolverWrapper(cc)
	cc.balancerWrapper = newCCBalancerWrapper(cc)
	cc.firstResolveEvent = grpcsync.NewEvent()
    */
	cc.initIdleStateLocked()
}

```

